<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Green Fog Blob with Parallax</title>
    <style>
        html,
        body {
            height: 100%;
            margin: 0;
            background: transparent;
            overflow: hidden;
        }

        canvas {
            display: block;
        }

        #image{
            position: absolute;
            width: 100%;
            height: 100%;
        }

        img{
            width: 12rem;
            height: 15rem;
        }

    </style>
    <script src="https://cdn.jsdelivr.net/npm/three@0.155.0/build/three.min.js"></script>
</head>

<body>

    <div id="image">

        <img src="./img/6b269c46ccec4a9d359175d34bfff978.jpg" alt="">
        <img src="./img//6f2a33d50e19e656c5d82288ec1b198c.jpg" alt="">
        <img src="./img/d2953ed9821f77cee650af7ea3c81390.jpg" alt="">
        <img src="./img/d71b4b2b1dc80746dd83b4d90404d7fd.jpg" alt="">
    </div>
    <script id="vert" type="x-shader/x-vertex">
    void main() {
      gl_Position = vec4(position, 1.0);
    }
  </script>

    <script id="frag" type="x-shader/x-fragment">
    precision highp float;

    uniform float u_time;
    uniform vec2  u_res;
    uniform vec2  u_mouse;

    // Simplex noise helpers
    vec3 mod289(vec3 x){return x - floor(x * (1.0/289.0)) * 289.0;}
    vec2 mod289(vec2 x){return x - floor(x * (1.0/289.0)) * 289.0;}
    vec3 permute(vec3 x){return mod289(((x*34.0)+1.0)*x);}
    float snoise(vec2 v){
      const vec4 C = vec4(0.211324865405187, 0.366025403784439,
                         -0.577350269189626, 0.024390243902439);
      vec2 i = floor(v + dot(v, C.yy));
      vec2 x0 = v - i + dot(i, C.xx);
      vec2 i1 = (x0.x > x0.y) ? vec2(1.0,0.0):vec2(0.0,1.0);
      vec4 x12 = x0.xyxy + C.xxzz; x12.xy -= i1;
      i = mod289(i);
      vec3 p = permute(permute(i.y+vec3(0.0,i1.y,1.0))+i.x+vec3(0.0,i1.x,1.0));
      vec3 m = max(0.5-vec3(dot(x0,x0),dot(x12.xy,x12.xy),dot(x12.zw,x12.zw)),0.0);
      m = m*m; m = m*m;
      vec3 x = 2.0*fract(p*C.w)-1.0;
      vec3 h = abs(x)-0.5;
      vec3 ox = floor(x+0.5);
      vec3 a0 = x-ox;
      m *= 1.79284291400159 - 0.85373472095314*(a0*a0+h*h);
      vec3 g;
      g.x = a0.x*x0.x+h.x*x0.y;
      g.y = a0.y*x12.x+h.y*x12.y;
      g.z = a0.z*x12.z+h.z*x12.w;
      return 130.0*dot(m,g);
    }

    // Fractal noise
    float fbm(vec2 p){
      float f = 0.0, a = 0.5;
      for(int i=0;i<5;i++){
        f += a*snoise(p);
        p *= 2.0;
        a *= 0.5;
      }
      return f;
    }

    void main(){
          vec2 uv = (gl_FragCoord.xy - 0.5*u_res) / u_res.y;
          float t = u_time*0.05;

          // --- Parallax effect ---
          uv += u_mouse * 0.010; // scale controls strength of shift

          // Make the fog wider (stretch on X axis)
          uv.x *= 0.7;

          // Distance from center (for radial glow)
          float d = length(uv*vec2(1.1,1.0));

          // Noise to fray the edges
          float edge = fbm(uv*3.0 + t);

          // Radial mask with noisy edge
          float mask = smoothstep(0.55, 0.25, d + edge*0.25);

    // Brighter, softer green base
    vec3 green = vec3(0.4, 0.9, 0.5);  

    // Add variation with noise (slightly stronger brightness)
    float intensity = 0.8 + 0.5 * fbm(uv*2.5 + t*0.5);

    vec3 color = green * intensity;

    // Slight glow effect by mixing in white near center
    color = mix(color, vec3(1.0), 0.15 * (1.0 - d));


            gl_FragColor = vec4(color, mask);

    }
  </script>

    <script>
        (() => {
            const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(innerWidth, innerHeight);
            renderer.setClearColor(0x000000, 0);
            document.body.appendChild(renderer.domElement);

            const scene = new THREE.Scene();
            const camera = new THREE.Camera();

            const uniforms = {
                u_time: { value: 0 },
                u_res: { value: new THREE.Vector2(innerWidth, innerHeight) },
                u_mouse: { value: new THREE.Vector2(0.0, 0.0) }
            };

            const mat = new THREE.ShaderMaterial({
                uniforms,
                vertexShader: document.getElementById("vert").textContent,
                fragmentShader: document.getElementById("frag").textContent,
                transparent: true
            });

            scene.add(new THREE.Mesh(new THREE.PlaneGeometry(2, 2), mat));

            // Animate
            let start = performance.now();
            function animate(now) {
                uniforms.u_time.value = (now - start) * 0.001;
                renderer.render(scene, camera);
                requestAnimationFrame(animate);
            }
            animate();

            // Resize
            addEventListener("resize", () => {
                renderer.setSize(innerWidth, innerHeight);
                uniforms.u_res.value.set(innerWidth, innerHeight);
            });

            // Mouse move listener
            document.addEventListener("mousemove", (e) => {
                // Normalize mouse position (-0.5 to 0.5)
                uniforms.u_mouse.value.x = (e.clientX / innerWidth - 0.5);
                uniforms.u_mouse.value.y = -(e.clientY / innerHeight - 0.5); // invert Y for natural feel
            });
        })();
    </script>
</body>

</html>